# <center/>思维题<center>

* ### 构造严格递增序列，差之和最小
    1. 将$b_{i}' = b_{i}-i$ 就可以将原来的$b_{i}，转化为求一个非下降序列$
    2. 题目求$|a_{i}-b{i}|和的最小值，同时将a_{i}按照上面的变化。a_{i}'-b_{i}'差不变$
    3. 做法：
        1. 将*a数组分成两部分*，前一半bi都相同为u，后一半对应的bi都相同值为v，u，v为对应a部分的中位数。
        2. 分类讨论若u<=v 答案为u+v，*u>v 答案为u,v的中位数*
        3. 一次遍历a的元素，每次刚加入一个元素单独看为一段C。*保证维护的所有段一定是递增的*若C大于当前维护的最大值则直接加入，否则就依次往回合并区间，新值为两段的中位数。最后的答案为所有段的和。答案一定是一段一段的
        4. 用左偏树维护中位数
            1. 每一次维护区间一半的数大根堆，根就是中位数。
            2. 线段合并，左偏树合并。但注意只在本题适用，因为每一次之插入一个数。（每一次插入一个数中位数变化只会在相邻的元素之间变化）两个区间合并，新的中位数一定在两个中位数之间AB，用左偏树维护时只维护一半的区间小于等于中位数，只用当某一个区间，AB中间没有数的时候才是正确的。
            3. 维护的一定是一半的元素 $[size/2]$ 当两个区间都是基数时要弹一个元素。
* ### 将$i-j变成单调序列的最小代价$
    1. 左偏树预处理，本质就是构造一个严格单调序列使得差最小
    2. 快速统计区间的绝对值之和，$mid*tree_sz-tree.sum +sum-tree.sz-mid(sz-tr.sz)$
    3. 枚举左端点，遍历右端点，做一遍左偏树操作
    <br/>
    
* ### 求数组相邻元素的差之和
    1. 可以连边 只要满足 $x<j<y,h[j]<h[x],h[j]<h[y]$。
    2. 贪心的求出每一条可行边的减少代价，然后选择代价最大的m条。
    3. 贪心的发现，边一定是在上升或者下降的从前往后+从后往前两边统计。单调的区间连边没有意义，边一点是包含不单调的部分。边优化掉不单调的代价。

<br/>

* ### 树上博弈dp转移
    1. 存在可以从该点网上跳1或者2或都可以
    2. $考虑dp(u,s1,s2)(s1,s2=0/1),表示先手从u开始是否获胜s1，fa(u)是否获胜s2,dp含义u的子树中是否存在先手必胜$ 转移如果可以跳1，2 $dp(u,s1,s2)|=dp(v,(!s1)||(!s2),s1)$只有u或者fu先手必败，则v先手必胜。
    3. 注意 dp表示是否存在这种可能
    4. 某一条边被去除后先手必败的条件
        1. $sz[u]==tot, !f[b][0][1]$ tot为所有获胜的叶节点的个数
<br/>

* ### 括号序列匹配
    1. 只要当左括号和右括号数目一样时一定能匹配
    2. 移动的一定是形如")("这样的。
    3. 每一次只能移动相邻的两个元素，最优条件当前有空的左括号则，右括号直接匹配.每一个右括号匹配的r一定是最左边没有匹配的。
    4. 统计答案：左括号sum++,右括号sum--。如果sum<0 每一次ans-=sum.
    5. 注意这种括号匹配的题，移动的一定是左括号。

<br/>

* ### 国际象棋棋版网格图
    1. 格子分奇偶$(x+y)%2分奇偶$
    2. 常用二分图图解决

* ### 距离最大值最小
    1. 选出若干相同的数，最小化下标的距离差。可以操作一次，改变任何一个数
    2. 一般这个题 $ans=max(Max/2,Second_Max)$不要忘记次大值。

* ### 在两个序列中找最大值之和
    1. 先求出sum1+sum2，然后可以用启发式合并的归并思路，减去每一次的较小的那一个。
    2. 但这中本质是分块根好n的方法要注意题目的数据范围，分析出题目最大的复杂度

* ### 树的直径变形
    1. 每一个边的边权不再是1，求树中简单路径的最大值。
    2. 类似树形DP不用换根一次DP就行。

* ### 求到简单路径最近距离值为k的点的个数
    1. 先算lca
    2. $ans=d[x][k]+d[y][k]-d[lca][k]-d[falca][k]-(d[x][k-1]+d[y][k-1]-2*d[lca][k-1]$ // 子树中的k-1要被剪掉
    3. $ans+=up[lca][k]$
* ### 换根统计向上距离为k的节点个数
    1. $up[i][k+1]=down[x][k]+up[x][k]-down[i][k-1]$


* ### 二分图博弈
    1. 题眼：不能经过重复的状态
    2. 其实状态再该图的二分图匹配上是先手必胜。

* ### 次数奇偶性
    1. 用01表示奇偶，用string 或者二进制数
    2. 用二进制，想道异或。用于处理伪回文题（可以重排字母）
    3. 如果一个数的xor就满足条件，那么可以提前往hash表里存一个0
    4. 
* ### 树上路径异或 就是两个节点的的异或值
    1. 从lca到B的异或=根到Bxor（lca到根）
    2. 任意路径转换AB为 $root-A xor root-B$
    3. 用dfs求出所有点的xor

* ### 构造矩阵使得每行a个1，每列b个1
    1. 构造思路：循环的在m列填1 a[i][id]=1,id=(id+1)%m;
    2. 思路应该是平均分配去构造
    3. 只要a*n==b**m就一定可以构造
    
* ### 求网格图割点
    1. 求两条轮廓，上轮廓，下轮廓，删除交集就可以使得不连通。
    2. 上轮廓优先往右后往下，下轮廓优先往下后往右
    3. 优化，在求上轮廓时，顺便将该条路径点都翻转。再一遍dfs，如果不连通了就说明，两条路径有交集。

* ### $p_{[i]}>p_{[i/2]}$
    1. 本质上就是求一个排列满足小根堆的性质
    2. 看到这种形式+排列想到完全二叉树。
    3. 统计方案数，就递归的去计算。并且递归的时候根节点一定是最小的值


* ### 树上计数
    1. prufer编码
        1. n 个点的带标号无根树数量
            $n^{n-2}$
        2. n 个点的带标号有根树数量。
            $n^{n-1}$
        3. 无向树编码方式
            1. 找叶节点且编号最小，将该点的父节点加入序列，并删除该叶节点
            2. 由编码求树
                1. 将序列的出现次数，列出每一个点儿子节点的个数
                2. 顺次遍历序列得到当前编号C，每一次选择编号最小的叶节点A，将A设成C的儿子，删除A，C的儿子-1
    2. n 个点的无标号有根树数量。
    3. n 个点的无标号无根树数量。

* ### 优化贪心的方案
* 如果题目中选择k个数，但是每种数的代价不同，有些不需要代价。一般来说不要把不需要代价的方案和其他方案一起算。用类似前缀和的方法枚举分给不需要代价的方案的数目，剩下的方案给要代价的。

* ### 数位DP的思维优化
* 当题目给出要求的数字不能出现k时k<=9,k>=0,可以将数字转化为9进制数强制转为为9禁止数。然后大于等于k的数位+1 $4->5,5->6$


* ### 滑动窗口dp技巧
* 例：任意连续k个数c至少出现一次，其他数>=c,本质，滑动窗口最小值为c
    1. $f[i]表示前i个数满足条件的方案数,a[i]=v, f[i]=\sum_{i-k+1}^{i}x^{i-j}f[j-1]$一般来说都可以用等差数列的方式优化递推式。求$f[i],f[i-1]的关系$
    2. 技巧就是滑动窗口多开一位ans=f[len+1],这样就可以统计所有的答案，不用累加最后k个数的答案。

* ### 计数专题
    1. 常见套路
        1. *线段计数问题*：（统计线段相交）
            1. 先排序(左或右看实际情况)一般来说用DPf[i]表示当前处理的第i个线段，然后取判断它和前面i-1的关系来就递推方程，有时候要用类似数量的方法优化DP
        2. *子集合问题*
            1. 先从简单入手比如n==1，来求ans。当和集合中的元素没有关系的时候，只有考虑n=1的res，$ans=res^P，P为集合大小$
        3. *棋盘放置问题*
            1. 用DP，观察放的棋子有没有什么性质，比如车。可以用f[i][k]表示前1-i行放了k个车，因为车一列只有一个所以方案数为$C_{m-k+1}^1$
            2. 一行选一个一列选k个但不能超过选的全部数量的一半：容斥原理每行选不超过一个的方案-每行选不超过一个某一列选的超过一半。枚举特殊的那一列 $f[i][j][k]表示当前处理第col列，这列在前i行选了j个，其他行选k个$，优化表达式$f[i][j]的j表示上个式子中的j-k，因为不关心具体值$
        4. *选m个子集，所有子集中1-n每一个出现的次数都是偶数次*，那么只要钱i-1个子集确定了第i个集合一定确定$ans=A_{2^n-1}^{i-1}$
        5. *堆类型的计数*：$任意的i[2,n],p_i>p_{i/2}$,显然这是一个最小堆的。定义$f[i]表示以i为根的子树的方案数f[i]=C_{sz-1}^{sz[l]} f[l]*f[r]$
        6. *博弈论类型的DP计数*
            1. 考虑二进制位DP 考虑必败态异或和为0，$f[i][j]表示前i位每一位异或和都是0，填了j个数。当前位填的数都是j+=(1<<i)$ j表示填了几位，或者是还剩几位的情况要根据最后容斥原理求答案来看
        7. 序列中的数都是不超过m 的正整数，而且这n 个数的和是p 的倍数。考虑$dp[i][j],j位前面的和modp的值$
    2. 特殊点：
        1. *欧拉错排* $D_n=(n-1)(D_{n-1)+D_{n-2}$
        2. *Polya定理：一个置换来说，分成若干个互补相关的循环，$ans=1/n*m^c，c为循环数$。一般来说都是对于圆环，旋转置换$k=0-(n-1)$考虑每一个循环点的个数为$n/gcd(n,k)循环数gcd(n,k).ans=\sum_{k=1}^{n-1}m^{gcd(n,d)} 由莫比乌斯反演 an \sum_{d|n}n^d[gcd(n/d,k)==1]，用欧拉函数$
        3. *笛卡尔树+DP*：给定一个N列的表格，每列的高度各不相同，但底部对齐，然后向表格中填入K个相同的数，填写时要求不能有两个数在同一列，或同一行,求总方案数。
            1. 从最矮的作为根开始树形DP。因为横坐标是递增的，高度也是递增的两维想到笛卡尔树。将一层的矩形当作一个节点，然后DP，再加上这个节点内可以选的。
        4. *DAG图找树*$ans=\prod d(i) $,如果加边成环后 $ans-不合法的路径，就是那个环上的所有路径 f[i]=\sum _v f[v]/d[i]$
        5. 每一位都随便填写只是确定了范围，统计计数的时候用期望，每一个数出现的概率都是1/n

* ### 博弈论专题
    1. Nim
        1. k-Nim有N堆，每一次可以取1-k堆每一堆取任意多个
            1. 结论：将每一堆的s转成二进制，统计堆的所有的二进制位，若有一位$x%(k+1)!=0$先手必胜
        2. N堆每次取一堆取任意
            1. $\sum_i^n ans xor s_i 为0后手$
            2. 改变，从n中选若干堆并且指定开始拿的堆
                1. 先手必败：
                    1. 所有的异或和为0
                    2. 不为0时，第一堆的石子个数小于其他堆的xor
        3. 阶梯NIm
            1. 每一次将一个阶梯的石子往前移，但不能越过石子。
            2. 结论：开始为第0阶，所有奇数位置上的石子的异或和非0先手必胜。从1开始的话就是偶数堆
            3. 只要是往一个方向移动棋子，并且不能越过的题，都可以俩俩分组，值为两个的差-1.，然后阶梯Nim，奇数堆异或和。要注意第一个前面的部分看成是第0阶。
        4. 斐波那契额Nim
            1. Zeckendorf定理（齐肯多夫定理），正整数都可以表示成若干个不连续的斐波那契数之和
            2. 每一次不超过上次的2倍，第一次不能全部取。
                1. 结论n为斐波那契数则先手必败。关键$f[k+1]<2*f[k]$
                2. n不是的话，分解为若干个不连续的斐波那契数，先手取最小的就是最优策略。因为后手一定取不完次小的堆，那问题就转换成n=f[k]的博弈。
    2. 两对石子为1组
        1. 每一次移除一堆，从另外一堆分若干个到这一堆。
        2. $SG(x,y),表示 x+1，y+1个石子的sg$定义$S_z满足x+y+1==z的sg(x,y)构成的集合$
        3. 结论$sg(x,y)=mex(S_x|S_y)=f(x|y),fx表示的是x二进制位最后一个0的位置（从0开始）$
    3. 每一次取不超过前一次两倍
        1. 第一次限制最多2次，求可以获得最高价值
            1. $f[i][j]表示还是1-i个，前一次取j个的方案数$关键是，取k个的最大价值为*sum[1-i]-f[i-k][k]*
    4. 石子合并
        1. 刚开始都是1，每一堆不能超过m不能合并输
        2. 结论 n<=m,合并次数n-1奇数先手，n为偶先手。n>m,最后一定是若干个m和n%m,因为刚开始为1，*如果拉到最长的操作次数我们必胜的话，那么不管对面怎么操作，我们都能用上述方法拉回来同样如果最长的操作是对面必胜，不管我们怎么合并，对面也能用上述方法拉回来* ，最后看合并的次数奇数先手
    5. 异或前缀和的性质
        1. 相邻两个自然数中较小的是偶数时两数异或和为 1
        2. 连续四个自然数中最小的是偶数时四个数的异或和为 0
        3. 偶数 x xor 1 =x+1
        4. $f[i]= i(imod4==0),1(imod4==1),i+1(imod4==2),0(i%4==3)$
    6. 树形博弈
        1. 必败点：它连接的所有点都是必胜点
        2. 加边
            1. 从根开始走，沿着有向边走到叶节点。
            2. 已知先或后手可以加一条边，问能不能赢
            3. 先dfs处理所有的边，成环不可取，因为永远不会结束。只能是往下连lose-lose，并且当前lose点能加边的条件是父节点只有1个子节点。否则加了没用，return
        3. 取叶子，每一次删除若干的叶子节点
            1. 结论：当前以S为节点的子树，在任意一个非也叶节点加上一个叶节点，一定先手必胜
            2. 当S子树中，存在某一个叶节点不是孤独的叶子(其父节点的子节点有>=2个叶节点)，则先手必胜
            3. 若所有的也节点都是孤独的，则统计每一个叶节点到其，深度最大的儿子个数>=2的祖先（不含这个点）的点数，若都是偶数则先手必败
        4. 点权
            1. 拆点算每一个点对于最后答案的贡献，然后按照贡献从大到小选.一般贡献就是看子树和看祖先节点的个数
    7. SG函数性质
        1. x的后继状态$[0,f(x)],f(x)为增函数时$SG函数值不减 $sg(x)=sg(f(x))+1$
    8. 纳什均衡
        1. 例：A有n种策略，B有m种策略。先手策略各项和为1，后手同。考虑$F_{xy},表示先手采用x，后手y的贡献是$
        2. 先手必然有一个策略最大化其分数，后手必然也有一个策略最小化先手的分数，这两个值必然是相等的，这两个策略称作纳什均衡

* ### 二维偏序问题总结
    1. 求$a_ia_j==b_i b_j$
        1. 每一组ab同时除$gcd(a,b),ans +=ma[{y,x}]$
        2. 当两个数互质后，最简分数的乘积为1，只能是互为倒数。
    2. $ a xor b=2*(a and b)$
        1. 按位考虑，发现$x_i xor y_i = x_{i-1} and y_{i-1}$由x和y的前一位推出当前位，所以当x固定时，y也唯一。枚举x从0-63计算y

* ### 数组中统计i前面连续的比他小的数的个数
    1. 单调栈，注意单调栈存的是下表。加入一个数时，弹去比他小的元素，则栈顶的元素就是上界，$ans=i-top$
    2. 一般算每一个点的在子数组中的贡献时都是考虑每一个点+单调栈，求出满足条件的连续的部分

    
* ### 超车问题
    1. 给定起点，和速度求是否会超车
        1. 判定条件$起点A<起点B，终点A<终点B$则不会超车。若给定了起点的限制，只用判断终点是否不满足条件
* ### 序列操作后相等
    1. 模型1:两种操作给定xy，xy同时加1或减，或x+y-或x-y+，每一种操作任意执行，次数不限。问能否让序列a=b
        1. 考虑并查集+巧妙建边。不单纯按照题目的要求操作a，假设同时操作两个序序列。两倍的点表示b同时加或加$x-y+n,y-x+n$一加一减$x-y,x+n-y+n$.边表示两个点一个加一个减。等效的。
        2. 枚举i和i+n，若不在同一集合，判段两个集合是否和相同。在同一集合，判断和是不是偶数。因为同一集合的元素相互之间的操作，要么sum不变要么就是+=2，为了a==b，必须$sum%2==0$