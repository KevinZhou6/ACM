# 网络流




* ### 流网络

1. 基本知识
    源点，汇点
    可行流：边上的流量，容量限制，流量守恒，流入点x的所有流量等于流出。
    可行流流量：从源点流出的总流量-流入，最大流=最大可行流，
    残留网络：Gf，可行流不同，残存网络不同，点集=原图点，边集多包含所有反向边。原边的方向边权变为，容量-流量，反向边=原来的边权。原网络可行流+对应残留网络的可行流依旧是原图的可行流。
       推论，如果残存网络可以找到从源点到汇点的可行里且》0，则原可行流不是最大流。
    增广路径，残留网络，从源点到汇点，沿着容量大于0的边走。
    割：把点集完全分开不想交的两个部分，源点S，汇点在T；
    割的容量，从S到T的所有边的容量和。只算从S到T
    最小割：容量最小值。对于任意一个可行流的割的流量都小于等于割的容量
    割的流量，从S-》T-从T-》S。但流网络固定，割的流量不一定固定，因为可行流不同 f(S,T)=-f(S,T),f(Z,XUY)=f(Z,X)+f(Z,Y),XY无交集。
    最大流最小割定理：最大流小于等于最小割。
    不存在增广路径，f是最大流，存在一个割，使得可行流流量等于割的容量
    A.维护残留网络，每一次迭代当前Gf找增广路，bfs
    B.更新残存网络，正向流量c-k,反向b+k.找k，增广路的最小流量边权

2. Dinic算法：
用分层图思想，每一次只能从上一层到下一层，避免环，从起点bfs距离就是层数。用dfs找出所有增广路，一次增广。（N2M）
关键在于优化 
1当前弧优化，某个点的某些边在dfs的时候已经满了，当在一起搜索到这个点时，就跳过这个条边。
2 dfs优化，当dfs时某一条边搜下去的返回值为0，说明不可用，将这个点层数设成-1.
3 flow<limit 当dfs的时候后面点的flow已经等于limit，没有必要再搜下去
```cpp
void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 0, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T)  return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}


int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;  // 当前弧优化
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}


```
***
* ### 二分图匹配
1. 建图：增加S和T，一个部分连S，另一个连T，二分图内部边正常连，容量都是1。可行流必须是整数 dinic
匹配的方案数就是枚举中间的所有边看谁的边流量等于容量。

1. 多重匹配： 一个点可以匹配多个点。一个点能匹配n次从S连容量为n的，另一个集合点能匹配m个点，连向T容量为m

<br/>

****
<br/>
<br/>
    
* ### 上下界可行流
    #### 无源汇上下界*可行流*
    1. 求一个可行的方案即可，不用求最大流,判断新图是否是满流，最大流等于所有从源点出去的边。
    <br/>
    
    2. 改变给定网络的容量限制变为 $C_{up}-C_{down}$ ，变成新图。并且新图的新的可行流$f$为新图的最大流。*注意：新图的网络要满足流量守恒，需要判断每一个点，是否要从源点连边或者连向汇点，大小为$C_{int}-C_{out}$*。因为是容量守恒，所以原点到某一个点的边的流量都是满的，*从原点出发的所有边都是满流*。
    <br/>
    
    3. 转换为原图的可行流，只要再新图的最大流的每一条边加上边的容量下界。
    4. 构造图：判断每一个点所有入边的容量下界之和和出边的容量下界之和。*入大于出，从源点连边，否则连向汇点* 
    
    ```cpp
    void add(int a,int b, int c,int d)
    {
        e[idx] =b, ne[idx] =h[a] ,f[idx] =d-c, l[idx]  =c,h[a] =idx++;
        e[idx] =a, ne[idx] =h[b] ,f[idx] =0 ,h[b] = idx++;
        A[a]-=c,A[b]+=c;
    }
    
     for(int i =1;i<=n;i ++)
    {
        if(A[i] >0 )add(S,i,0,A[i]),tot+=A[i];
        else if(A[i]<0)add(i,T,0,-A[i]);
    }
    ```
    ****
    <br/>
    <br/>
    
    #### 有源汇上下流*最大流*
    1. 定义：图中给定了源点和汇点
    2. 先将源点和汇点都变成流量守恒，在S和T之间连一条$\infty$的边
    3. 方法：先根据上一题建图，再建立虚拟源点，求一遍满流。然后删去新建的到两个虚拟源点的边，从新求一遍S-T的最大流。
    4. *加一个从T到S的边*，答案就是新图的从S到T的流+重新跑一遍dinic求的最大流
    ```cpp
    if (dinic() < tot) puts("No Solution");
    else
    {
        int res = f[idx - 1];
        S = s, T = t;
        f[idx - 1] = f[idx - 2] = 0;
        printf("%d\n", res + dinic());
    }
    ```
    

    #### 有源汇上下流*最小流*
    1. 最小值就是将上面的从s-t的最大流，变成从t到s，答案为减法。
    2. *一定要删除从t到s的之间加的那条边* 
    3. ```cpp
         int res = f[idx - 1];
        S = t, T = s;
        f[idx - 1] = f[idx - 2] = 0;
        printf("%d\n", res - dinic());
        ```
    
    
    #### 多源汇最大流
    1. 建立虚拟源点汇点S，T，从S向每一个源点，建立一条$+\infty$的边,从汇点向虚拟汇点连容量$\infty$的边
    2. 跑一遍dinic从虚拟源定到虚拟汇点的最大流
    ```cpp
    while (sc -- )
    {
        int x;
        scanf("%d", &x);
        add(S, x, INF);
    }
    while (tc -- )
    {
        int x;
        scanf("%d", &x);
        add(x, T, INF);
    }
    ```
    
    #### 关键边
    将某一条边的容量增大，使得新图的最大流变大。
    *选择条件：只选择流量==容量的边*
    *同时在$G_f$中存在从S-u和v-T的路径*
    1. 方法：
        1. 先用dinic求最大流
        2. 从源点dfs判断能搜到的点，用正向边
        3. 从汇点dfs判断能搜到的点，*走一条边，要判断反向边是否满足边大于0才能走*
        4. 统计正向边

        
* ### 最大流判定
    例：无向图：1-N走T次，每条边只能用1次，求最大边权长的最小值
    *二分+最大流判定*
    1. 思路
        1. 建立流网络，容量都是1.
        2. 求一遍最大流 最大流的值表示不相交的路径条数
        3. 无向图每一个方向都建边，但没有必要建4条边，可以容量累加
        4. 将残留网络的反向边当成了无向图的另一条边
    2. 引入分层图---- 给网络增加距离的概念
        1. 网络流中引入分层图的概念建图，可以表示网络流中的距离
        2. 可以不用二分，因为每一次都要建边，且day比较小
         ![截屏2023-06-27 下午1.49.04](media/16940823557501/%E6%88%AA%E5%B1%8F2023-06-27%20%E4%B8%8B%E5%8D%881.49.04.png)
         

        3. 建图代码
            ```cpp
            add(S,get(0,0),k);
            add(get(n+1,0),T,INF);
            int day=1,res=0;
            while(true)
            {
                add(get(n+1,day),T,INF);
                for(int i=0;i<=n+1;i++)
                add(get(i,day-1),get(i,day),INF);
                for(int i=0;i<m;i++)
                {
                     int r = ship[i].b;
                    int a = ship[i].id[(day - 1) % r], b = ship[i].id[day % r];
                    add(get(a, day - 1), get(b, day), ship[i].a);
                }
                
                res +=dinic();
                if(res>=k)break;
                day++;
            ```
         ***
         
         
* ### 拆点
    * 思路
        * 将点拆成入点和出点，将点的限制转变为入点和出点的边的容量C。
        * 比如每一个点只能匹配一个点，那么C=1
    1. 三分图匹配
        1. 将中间的点拆成入点和出点，一个集合连向入点，出点连向另一个集合。
        2. 代码
            ```cpp
            S = 0, T = n * 2 + F + D + 1;
            memset(h, -1, sizeof h);
            for (int i = 1; i <= F; i ++ ) add(S, n * 2 + i, 1);
            for (int i = 1; i <= D; i ++ ) add(n * 2 + F + i, T, 1);
            for (int i = 1; i <= n; i ++ )
            {
                add(i, n + i, 1);
                int a, b, t;
                scanf("%d%d", &a, &b);
                while (a -- )
                {
                    scanf("%d", &t);
                    add(n * 2 + t, i, 1);
                }
                while (b -- )
                {
                    scanf("%d", &t);
                    add(i + n, n * 2 + F + t, 1);
                }
        

            ```
    2. 最长上升子序列，每个点只被选1次的数目
        1. 计算其最长递增子序列的长度 s
            $DP 最长上升子序列$
        2. 计算从给定的序列中最多可取出多少个长度为 s的递增子序列。（给定序列中的每个元素最多只能被取出使用一次）
            1. 建图S连向所有f为1的点，所有f为s的点连向T
            2. 不同的点---用拆点技巧 边权为1
            3. 中间点由dp转移来的点连边
        3. 如果允许在取出的序列中多次使用 x1和 xn，则从给定序列最多可取出多少个长度为 s 的递增子序列。
            1. 修改1和n号点S到T 容量$+\infty$的边
            2. 拆点的边变为$+\infty$
        4.代码
            ```cpp
                s=max(s,g[i]);
                if(g[i]==1)
                add(S,i,1);
                for(int j =1;j<i;j++)
                {
                    if(v[j]<=v[i]&&g[i]==g[j]+1)
                    add(n+j,i,1);
                }
                
                // 2与3的代码
            for(int i =1;i<=n;i++)
            if(g[i]==s)add(n+i,T,1);
            
            printf("%d\n",s);
            if(s==1)printf("%d\n%d\n",n,n);
            else
            {
                int res =dinic();
                printf("%d\n",res);
                for(int i=0;i<idx;i+=2)
                {
                    int a =e[i^1],b= e[i];
                    if(a==S&&b==1)f[i]=INF;
                    if(a==1&&b==n+1)f[i]=INF;
                    if(a==n&&b==n+n)f[i]=INF;
                    if(a==n+n&&b==T)f[i]=INF;
                }
                printf("%d\n",res+dinic()); //要加上原来的
            ```
    1. 判断汇点的选择
        1. 枚举每一个点是汇点，求最大流判断最大流是否等于题目中的数量限制。比如物品的个数，人数等

    * 总结拆点
         1. 如果遇到点上有流量限制---每一个点通过次数有限制，拆成入点和出点，边权为点的限制
         2. 找到边怎么连，怎么连源点和汇点
    ****
    
* ### 最小割
性质：
    1. 割的容量只算从S-T的，但流量算S-T - T-》S。
    2. 最大流==最小割的容量

1. 求解方法：
    1. 用dinic 求一遍最大流就行。
应用：
    1. 给出一个带权无向图 G=(V,E)，每条边 e 有一个权 we。求将点 s 和点 t 分开的一个边割集 C，使得该割集的平均边权最小。边割集的定义与最小割中的割边的集合不同。在本题中，一个边割集是指：将这些边删去之后，s 与 t 不再连通。
        1. 区别：边可以在集合内部取，可以多选
        2. 用01数分规划 设$y 使得 比值<=y 转换为 边权之和$
        3. 权值小于0必选，大于0用dinic求最小割
        4. 无向图将反向边也变为有意义的有向边
    
    2. 求边权之和最小
        1. 边权=两个点的异或和，已知一些点的编号，给剩余点赋编号，求剩余边权之和最小
        2. 按位贪心,*每一位独立*,依次枚举k，将集合分成两类，使得两个集合之间的边的数目最小
        3. 细节：让某个点必须和S在一个集合中，从S想a连一条$+\infty$的边
        4. 剩余的点不用做任何操作。因为最小割的集合，是不确定的确定的是最小割的值，所以只用保证已知编号的点固定在一个集合中即可。
* ### 最大权闭合图
    1. 有向图的点集，这些点的边都是在这个集合内部。点集的边不能指向点集外面。点集+边等于闭合图。可以指向里面，但里面的边不指向外面
    2. 最大权，权值在点上。找一个点集。
    3. 建图：
        1. 源点向所有点权为正的点连一条边，边权为点权
        2. 所有点权为负的边向汇点连一条边权为点权绝对值的边
        3. 中间的边为$+\infty$
    4. 关键特殊性标志：
        1. 权在点上。
        2. 要选择某一个点，必须要选择它所有连出去的边。
        3. 建边的时候要分清楚，边的方向。
    5. 答案为所有*正权和-最小割*
    6. 运用，当有限制时，比如要选择A必须要选择BC的时候，建立有向边，
        A->B，A->C
* ### 最大密度子图
    *本质为无向图，但没有关系，依旧用有向图做，只是度数有区别
    1. 要求子图中的边集，任意一个边，其两个点都在边集中
    2. 最大化 边的数量/点的数量，转变为01分数规划
    3. 最大化$|E'|-g|V'|$
    4. 性质：选择了点集，则必然要选择点集中的所有边
    5. 建图：
        1. 点数：V 边数2V+E，U取最大值m
        2. 二分r=m边数，判断n*U-dinic=$|E'|-g|V'|$,大于0，说明答案可以更大l=mid
        3. 最后的合法方案，从源点dfs 沿着流量大于0的边走到的点都是合法方案。
        4. 从S向每一个点连边权为U的边，从i到T连U+mid*2-dg[i] (度)
        5. 边权为1
    6.答案$(U*n-dinic())/2$;
    ```cpp
    //建边
    void build(double g)
    {
        memset(h, -1, sizeof h);
        idx = 0;
        for (int i = 0; i < m; i ++ ) add(edges[i].a, edges[i].b, 1, 1);
        for (int i = 1; i <= n; i ++ )
        {
            add(S, i, m, 0);
            add(i, T, m + g * 2 - dg[i], 0);
        }
    }
    
    //二分
     double l = 0, r = m;
    while (r - l > 1e-8)
    {
        double mid = (l + r) / 2;
        double t = dinic(mid);
        if (m * n - t > 0) l = mid;
        else r = mid;
    }
    ```
    7.细节 dinic边权要大于0才可以
* ### 改进最大密度子图
    1. 题目允许边权存在 E改进为边权和，边权>0才可以
    2. 改进内部边权为改变的权值，将dg改为这个点出去的所有边权和
    3. 同时有边权和点权。求$(|E|+|V'|)/|V|$权值和/点的个数，最大化$|E'|+|V'|-g|V'|$ 特殊问题中g可以等于0。只需要在原来的基础上多减去点v的点权*从i到T连U+mid2-dg[i]-2p[i]*
* ##### 总结 最大密度子图
    1. 找到U的最大值，保证从i到T的边权要大于等于0.没有边权时dg为度，有边权时为边权和，当点也有度数的时候要多减去点权。
    2. 注意点S到i，i到T，最后结果$(U*n-dinic())/2$;
    3. 要注意时有向图还是无向图，正向反向边权不一样。
    4. S到i和i到T的边是有向边，其余边为无向
    
* ### 二分图最小权点覆盖集
    1. 每一个流网络，每一个点有一个非负权值，*将权值建成容量*找一个点覆盖，权值和最小。
    2. 点覆盖：选择一个点集，覆盖所有的边
    3. 如果权都为1，用*匈牙利算法=最大匹配数*
    4. 每个点必须选一个，S到i或者i到T的边至少有一个是割边。
    5. 建图
        1. 源点S到i，i到T是点权。
        2. 中间的边是$+\infty$
    6. 输出方案，找点集即为，在最大流中找最小割：在残留网络中从S出发，沿着$f[i]>0$的边走，搜到的点为点集S。判断割边 ab a被搜到且b没有被搜到才是割边，割边一定是满流。a==S 说明b是左边的集合，b==T说明a是右边的集合
    7. 例：
        1. 一个有向图，可以花费a删除点出发的边，花费b删除到达点边
            1. 分析，删除一个边，只有两种操作要不就是a要不就是b，二选一->类似点覆盖
            2. 构造二分图,连的是无向边![截屏2023-07-04 下午9.05.11](media/16940823557501/%E6%88%AA%E5%B1%8F2023-07-04%20%E4%B8%8B%E5%8D%889.05.11.png)
            3. 有点像拆点，拆成入点和出点。
* ### 最大权独立集
    1. 最大权独立集 = 所有点的总权值-最小点覆盖
    2. 定义：选出的点集，任意点之间没有边
    3. 可以解决负权点的最小权点覆盖集，全部选上负权的点，方法细节：让某个点必须和S在一个集合中，从S想a连一条$+\infty$的边


* ### 最小割模型例题
    * 基本思路：构造流网络->证明简单割对应一种可行的方案
    1. 最小删除多少点，是的无向图不连通
        1. 最小割处理的是边，拆点把点变成边。有向边a->b 变成 a出到b入，a入连向a出。
        2. 不想成为割边的边容量$+\infty$，拆点后a入a出边权为1
        3. 边权为1 最小割对应的是边数。
        4. 不连通至少有两个点不能到达，类似源点汇点+最小割
    2. 最大闭合子图
        1. 标志，点权+选某一个点要选其发出的所有边
        2. 答案正权和-dinic
        3. 方案：找割边，$ st[a] , !st[b] $
* ### 费用流
    1. 定义：最大流的费用的最大的最小值
    2. 所有边的流量*边的费用。
    3. 性质：最大流一定有最小费用最大流
    4. 模板
        1. 将EK中bfs改成spfa，求S-T的最长路或者最小路
        2. 费：最小值：求最短路，最大值 求最长路。cost=flow*len
        3. 代码
            ```cpp
             void add(int a, int b, int c, int d)
            {
                e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;
                e[idx] = a, f[idx] = 0, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ;
            }
             bool spfa()
            {
                int hh = 0, tt = 1;
                memset(d, 0x3f, sizeof d);
                memset(incf, 0, sizeof incf);
                q[0] = S, d[S] = 0, incf[S] = INF;
                while (hh != tt)
                {
                    int t = q[hh ++ ];
                    if (hh == N) hh = 0;
                    st[t] = false;
            
                    for (int i = h[t]; ~i; i = ne[i])
                    {
                        int ver = e[i];
                        if (f[i] && d[ver] > d[t] + w[i])
                        {
                            d[ver] = d[t] + w[i];
                            pre[ver] = i;
                            incf[ver] = min(f[i], incf[t]);
                            if (!st[ver])
                            {
                                q[tt ++ ] = ver;
                                if (tt == N) tt = 0;
                                st[ver] = true;
                            }
                        }
                    }
                }
             void EK(int& flow, int& cost)
            {
                flow = cost = 0;
                while (spfa())
                {
                    int t = incf[T];
                    flow += t, cost += t * d[T];
                    for (int i = T; i != S; i = e[pre[i] ^ 1])
                    {
                        f[pre[i]] -= t;
                        f[pre[i] ^ 1] += t;
                    }
                }
            }
            
    1. 基本应用
        1. 一般中间的容量没有限制的话就是$+\infty$ 
        2. 最大费用最大流，求最长路spfa。将图中所有的费用取反
        3. 注意费用到底加在哪一条边上,一般费用都是在点之间S，T之间的边没有费用
        4. 费用流有双向边的时候不能，合并成正反向边，因为费用不同,限制每一点可以流出多少或者流入多少的限制，一般表现在从S到i或者从i到T；
    2. 二分图最优匹配
        1. 二分图最大匹配，边权都是1。
        2. 最大匹配==最大流，只用加上费用即可
    3. 最大权不相交路径
        1. 点有限制，拆点。
        2. 有多个源点，建立超级源点，*S向每一个源点连边容量为1*
    4. 网格图
        1. 走k次，从超级源点向起点连边容量为k，其他边的容量$+\infty$。
        2. 每个格子只有一次机会拿走费用，怎么实现：建两条边，1条边容量为1，费用为w，另一条边容量为$+\infty$费用为0
    5. 循环流动
        1. 一个流从某点a流入，某点b流出，只用在b->a连一条边容量$+\infty$
        
    6. 无源汇上下界最小费用可以行流
        1. 将容量加上下界，$c_{in} > c_{out} ,S->u $,$c_{out}> c_{in} ,u->T$
        2. 转变后只用求新图的最小费用最大流。
        3. 区别于上下界最大流
        4. S,T只是用于给新图补充流量的，必须要保证原图是流量守恒，所以有时会多加一个点作为汇点。